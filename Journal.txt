Journal: QuietCasting
Author: Pavlos Christoforou
Date: 2013-01-20

A Journal about QuietCasting, raising 3 kids, programming and technology.


Chapter: QC

Article: Introduction
Date: 2013-10-02
Topic: Wireless Protocols


QuietCasting is a low rate, low power, group chat or twitter style
communication technology having no central control nodes.


### Specs

 - A QuietCasting group is made of a number of QuietCasting
   nodes. Each QuietCasting node typically corresponds to a single
   user operating such node.

 - The size of a QuietCasting group corresponds to the size of a
   typical chat group. It is unlikely that the typical group size will
   exceed 30 nodes and is unlikely that each node will be transmitting
   at rates higher than 100 messages (each message about 32 bytes
   long) per hour (in a chat group comprized of a 30 users and at a
   rate of 100 messages per hour, each user will need to read about
   one SMS style message per *second*!)

 - Each node will use very low power (should run for many days if
   not weeks on a single battery charge).


### Design

 - Keep it Simple. Very simple. Each QuietCasting node is a pure
   broadcaster. There is no requirement that receiving nodes must
   aknowledge anything or indeed transmit anything at all upon
   reception of a transmitted message (Similar to FM radio or TV
   teletext).

 - To achieve such simplicity, the design allows the possibility of
   lost messages (like TV teletext) but in a manner where the
   probability of message loss is controlled by the communication
   protocol (specifically the error correcting code used) and can be
   made arbitrarily small (unlike TV teletext).



### Details

#### The raw communication layer

The raw communication layer (radio frequency, audio frequency or
otherwise) transmits data frames comprised of a 96 bit sync word
(providing the necessary receiver synchronization) and a 1280 bit data
frame.

    | 96 bit sync word | 1280 bit dataframe |


##### The sync word

The 96 bit sync word is provided below:

    101010101011101110001011111101111100001101001111000111101000000000100111010000110100001001001101


it was generated by taking the first 96 binary digits of the SHA256
checksum of 'quietcasting'. In python:
    
     bin(int(hashlib.sha256('quietcasting').hexdigest(), 16))[2:98]


##### The data frame

The data frame is structured as below (where numbers stand for 'bytes'):

    | node id (6b) | channel number (1b) | payload type (1b) | data payload (33b) |

and its total size is 6x the size of the above structure:

    1. 3x times simple repetition of the structure
    2. A running XOR of the randomized sequence  
which is repeated 3x times for error correction 
the factor of 8 is due to the redundacy (8x) added by the error
corecting code. The scheme currently uses a rate 8 repeat accumulate
code.

#### QuietCasting node requirements

Assuming 100 nodes sending 100 messages per hour and no collisions: 

    100 users * 100 msg per hour * (8 bytes sync word + 1024 bytes payload) = 22933.33 bits/sec

and each user/node transmitting on average at a rate of 230 bits/sec




Chapter: Web Publishing

Article: Introducing Journal
Date: 2013-01-20
Topic: Publishing


I have been following a number of technology focused blogs and it
appears to me that for a large class of such blogs the standard blog
model with its time line format is not appropriate. Other than helping
a frequent reader quickly locate an author's latest postings, the
creation time of each posting is largely irrelevant. What is relevant
is the topic or collection of topics to which each posting belongs to
and the blogs with the best user interface adhere to a well defined
and displined tagging strategy.

It would appear that the book format with its ordered collection of
chapters and sections is a much better way to organize such valuable
content, providing a better user interface and content guidance
to both casual and frequent readers.

These observations along with the complexity of many blogging systems
have motivated me to introduce a new format for such type of writting
which is closer to the format of a regular book. I call it simply a
*Journal*. 

A Journal is composed of a number of chapters and each chapter is
composed of a number of articles. Each article's set of attributes is
limited to a title, a date, an author and a topic. I wish, initially
at least, to keep the model very strict and limited and mostly
applicable to my particular requirements. Such a limited model
faciliates easy organizational decisions and yields a simple library
implementation. Too many libraries and systems/frameworks in the
python world tend to be overengineered, making them unncessary complex
to use and very hard to modify.

### Implementation

1. The contents of a journal (or even multiple journals) are organized
in a single large text file. Good editors (Emacs/VIM/Sublime Text) are
extremely powerfull applications offering incredible
editing/navigation/search/replace facilities withing a single buffer
or file. They are not as effective when working across a large
collection of files especially if those files are organized in a
hierarchical directory structure.

2. Journals, chapters and articles will be defined in terms of simple
double colon field definitions and the actual content of each article
will be written in markdown.

3. The publishing system will be a single python file with a good
command line interface.

4. The output generated will be static html with some client site
JavaScript initially targeting bootstrap.js.




